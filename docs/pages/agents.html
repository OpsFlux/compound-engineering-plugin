<!DOCTYPE html>
<html lang="zh-CN" class="theme-dark">

<head>
  <meta charset="utf-8" />
  <title>代理参考 - 复合工程</title>
  <meta content="复合工程插件中所有 23 个专业 AI 代理的完整参考。" name="description" />
  <meta content="width=device-width, initial-scale=1" name="viewport" />

  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" />
  <link href="../css/style.css" rel="stylesheet" type="text/css" />
  <link href="../css/docs.css" rel="stylesheet" type="text/css" />
  <script src="../js/main.js" type="text/javascript" defer></script>
</head>

<body>
  <div class="background-gradient"></div>
  <div class="docs-layout">
    <aside class="docs-sidebar">
      <div class="sidebar-header">
        <a href="../index.html" class="nav-brand">
          <span class="logo-icon"><i class="fa-solid fa-layer-group"></i></span>
          <span class="logo-text">CE文件</span>
        </a>
      </div>
      <nav class="sidebar-nav">
        <div class="nav-section">
          <h3>入门</h3>
          <ul>
            <li><a href="getting-started.html">安装</a></li>
          </ul>
        </div>
        <div class="nav-section">
          <h3>参考</h3>
          <ul>
            <li><a href="agents.html" class="active">代理商 (23)</a></li>
            <li><a href="commands.html">命令 (13)</a></li>
            <li><a href="skills.html">技能 (11)</a></li>
            <li><a href="mcp-servers.html">MCP 服务器 (2)</a></li>
          </ul>
        </div>
        <div class="nav-section">
          <h3>资源</h3>
          <ul>
            <li><a href="changelog.html">变更日志</a></li>
          </ul>
        </div>
        <div class="nav-section">
          <h3>在此页上</h3>
          <ul>
            <li><a href="#review-agents">评论 (10)</a></li>
            <li><a href="#research-agents">研究 (4)</a></li>
            <li><a href="#workflow-agents">工作流程 (5)</a></li>
            <li><a href="#design-agents">设计 (3)</a></li>
            <li><a href="#docs-agents">文件 (1)</a></li>
          </ul>
        </div>
      </nav>
    </aside>

    <main class="docs-content">
      <div class="docs-header">
        <nav class="breadcrumb">
          <a href="../index.html">家</a>
          <span>/</span>
          <a href="getting-started.html">文档</a>
          <span>/</span>
          <span>代理商</span>
        </nav>
        <button class="mobile-menu-toggle" data-sidebar-toggle>
          <i class="fa-solid fa-bars"></i>
        </button>
      </div>

      <article class="docs-article">
        <h1><i class="fa-solid fa-users-gear color-accent"></i> 代理参考</h1>
        <p class="lead">
          将座席视为您从不睡觉的专家队友。这里有 23 名专家，每一位都专注于一个领域。当您需要集中的专业知识时，可以单独致电他们，或者将他们组合在一起进行多角度分析。他们固执己见，速度很快，而且比你更记得你的代码库。
        </p>

        <div class="usage-box">
          <h3>如何使用代理</h3>
          <div class="card-code-block">
            <pre><code># Basic invocation
claude agent [agent-name]

# With a specific message
claude agent [agent-name] "Your message here"

# Examples
claude agent kieran-rails-reviewer
claude agent security-sentinel "Audit the payment flow"</code></pre>
          </div>
        </div>

        <!-- Review Agents -->
        <section id="review-agents">
          <h2><i class="fa-solid fa-code-pull-request"></i> 审查代理 (10)</h2>
          <p>您的代码审查梦之队。这些代理能够捕捉到人类在凌晨 2 点错过的东西——安全漏洞、性能悬崖、架构漂移以及那些“它有效但我讨厌它”的时刻。他们很挑剔。他们意见不一。这就是重点。</p>

          <div class="agent-detail" id="kieran-rails-reviewer">
            <div class="agent-detail-header">
              <h3>kieran-rails-审稿人</h3>
              <span class="agent-badge">导轨</span>
            </div>
            <p class="agent-detail-description">
              您的高级 Rails 开发人员见过太多“聪明”的解决方案在生产中失败。痴迷于枯燥、可预测且可维护的代码。对现有代码严格（因为触及它会带来一切风险），对新的孤立功能务实（因为运输很重要）。如果您曾经想过“这有效但感觉不对”，这位评论家会告诉您原因。
            </p>
            <h4>关键原则</h4>
            <ul>
              <li><strong>现有代码修改</strong> - 非常严格。增加复杂性需要强有力的理由。</li>
              <li><strong>新代码</strong> - 务实。如果它是隔离的并且有效，那么它是可以接受的。</li>
              <li><strong>涡轮流</strong> - 简单的涡轮流必须是控制器中的内联数组。</li>
              <li><strong>测试作为质量</strong> - 难以测试的代码=需要重构的糟糕结构。</li>
              <li><strong>命名（5 秒规则）</strong> - 必须从名称中了解视图/组件在 5 秒内的作用。</li>
              <li><strong>命名空间</strong> - 始终使用 <code>class Module::ClassName</code> 图案。</li>
              <li><strong>重复 > 复杂性</strong> - 简单的重复代码比复杂的 DRY 抽象更好。</li>
            </ul>
            <div class="card-code-block">
              <pre><code>claude agent kieran-rails-reviewer "Review the UserController"</code></pre>
            </div>
          </div>

          <div class="agent-detail" id="dhh-rails-reviewer">
            <div class="agent-detail-header">
              <h3>dhh-rails-审稿人</h3>
              <span class="agent-badge">导轨</span>
            </div>
            <p class="agent-detail-description">
              如果 DHH 审查您的 Rails PR 会怎样？他会问你为什么要在 Rails 中构建 React，为什么表单需要六层抽象，以及你是否忘记了 Rails 已经解决了这个问题。这个代理引导着这种能量——生硬、固执己见、对复杂性过敏。
            </p>
            <h4>重点关注领域</h4>
            <ul>
              <li>识别与 Rails 约定的偏差</li>
              <li>发现 JavaScript 框架模式渗透到 Rails</li>
              <li>分解不必要的抽象</li>
              <li>过度工程和微服务心态的挑战</li>
            </ul>
            <div class="card-code-block">
              <pre><code>claude agent dhh-rails-reviewer</code></pre>
            </div>
          </div>

          <div class="agent-detail" id="kieran-python-reviewer">
            <div class="agent-detail-header">
              <h3>kieran-python-评论者</h3>
              <span class="agent-badge">Python</span>
            </div>
            <p class="agent-detail-description">
              你的 Python 完美主义者相信类型提示不是可选的，并且 <code>dict.get()</code> 击败 try/ except KeyError。期望现代 Python 3.10+ 模式——没有遗留语法，没有 <code>typing.List</code> 什么时候 <code>list</code> 本机工作。如果您的代码看起来像 Java 翻译成 Python，请准备重写。
            </p>
            <h4>重点关注领域</h4>
            <ul>
              <li>所有功能的键入提示</li>
              <li>Pythonic 模式和习语</li>
              <li>现代 Python 语法</li>
              <li>进口组织</li>
              <li>模块提取信号</li>
            </ul>
            <div class="card-code-block">
              <pre><code>claude agent kieran-python-reviewer</code></pre>
            </div>
          </div>

          <div class="agent-detail" id="kieran-typescript-reviewer">
            <div class="agent-detail-header">
              <h3>基兰打字稿审稿人</h3>
              <span class="agent-badge">打字稿</span>
            </div>
            <p class="agent-detail-description">
              TypeScript 的类型系统是一份礼物——不要把它扔掉 <code>any</code>。这位审稿人对待 <code>any</code> 就像需要合理化的代码味道一样。期望正确的类型、干净的导入和不需要注释的代码，因为类型解释了一切。为了安全起见，您添加了 TypeScript；该代理确保您确实得到它。
            </p>
            <h4>重点关注领域</h4>
            <ul>
              <li>No <code>any</code> 无理地</li>
              <li>组件/模块提取信号</li>
              <li>进口组织</li>
              <li>现代 TypeScript 模式</li>
              <li>可测试性评估</li>
            </ul>
            <div class="card-code-block">
              <pre><code>claude agent kieran-typescript-reviewer</code></pre>
            </div>
          </div>

          <div class="agent-detail" id="security-sentinel">
            <div class="agent-detail-header">
              <h3>安全哨兵</h3>
              <span class="agent-badge critical">安全</span>
            </div>
            <p class="agent-detail-description">
              安全漏洞隐藏在无聊的代码中——“只需从参数中获取用户 ID”行，将权限升级错误带入生产环境。该代理像攻击者一样思考：SQL 注入、XSS、身份验证绕过、泄露秘密。在接触身份验证、付款或任何涉及 PII 的内容之前运行它。您的用户数据取决于偏执狂。
            </p>
            <h4>安全检查</h4>
            <ul>
              <li>输入验证分析</li>
              <li>SQL注入风险评估</li>
              <li>XSS漏洞检测</li>
              <li>认证/授权审核</li>
              <li>敏感数据曝光扫描</li>
              <li>OWASP 前 10 名合规性</li>
              <li>硬编码秘密搜索</li>
            </ul>
            <div class="card-code-block">
              <pre><code>claude agent security-sentinel "Audit the payment flow"</code></pre>
            </div>
          </div>

          <div class="agent-detail" id="performance-oracle">
            <div class="agent-detail-header">
              <h3>性能预言机</h3>
              <span class="agent-badge">表现</span>
            </div>
            <p class="agent-detail-description">
              您的代码适用于 10 个用户。 10,000 时会发生什么？该代理会通过时间旅行解决您未来的扩展问题 - 破坏数据库的 N+1 查询、隐藏在循环中的 O(n²) 算法、丢失索引、内存泄漏。它以大 O 表示法进行思考，并提出一些令人不舒服的问题：当流量激增时，什么首先发生故障。
            </p>
            <h4>分析领域</h4>
            <ul>
              <li>算法复杂度（大O表示法）</li>
              <li>N+1查询模式检测</li>
              <li>正确的索引使用验证</li>
              <li>内存管理回顾</li>
              <li>缓存机会识别</li>
              <li>网络使用优化</li>
              <li>前端捆绑影响</li>
            </ul>
            <div class="card-code-block">
              <pre><code>claude agent performance-oracle</code></pre>
            </div>
          </div>

          <div class="agent-detail" id="architecture-strategist">
            <div class="agent-detail-header">
              <h3>架构策略师</h3>
              <span class="agent-badge">建筑学</span>
            </div>
            <p class="agent-detail-description">
              每一个“小变化”要么强化你的架构，要么开始侵蚀它。该代理会缩小范围，查看您的修复是否确实适合系统的设计，或者您是否将胶带固定在摇摇欲坠的地基上。它阐述了 SOLID 原则、微服务边界和 API 契约。当你要做出“感觉很奇怪”的改变时，请调用它。
            </p>
            <h4>分析领域</h4>
            <ul>
              <li>整体系统结构理解</li>
              <li>改变架构内的环境</li>
              <li>建筑违规识别</li>
              <li>遵守坚实的原则</li>
              <li>微服务边界评估</li>
              <li>API合同评估</li>
            </ul>
            <div class="card-code-block">
              <pre><code>claude agent architecture-strategist</code></pre>
            </div>
          </div>

          <div class="agent-detail" id="data-integrity-guardian">
            <div class="agent-detail-header">
              <h3>数据完整性守护者</h3>
              <span class="agent-badge critical">数据</span>
            </div>
            <p class="agent-detail-description">
              一旦在生产环境中运行，迁移就无法回滚。在您意外删除包含用户数据的列、在事务中创建竞争条件或违反 GDPR 之前，此代理是您的最后一道防线。它痴迷于引用完整性、回滚安全性和数据约束。您的数据库是永久的；移民应该是偏执的。
            </p>
            <h4>审查领域</h4>
            <ul>
              <li>迁移安全性和可逆性</li>
              <li>数据约束验证</li>
              <li>交易边界审查</li>
              <li>引用完整性保存</li>
              <li>隐私合规性（GDPR、CCPA）</li>
              <li>数据损坏场景检查</li>
            </ul>
            <div class="card-code-block">
              <pre><code>claude agent data-integrity-guardian</code></pre>
            </div>
          </div>

          <div class="agent-detail" id="pattern-recognition-specialist">
            <div class="agent-detail-header">
              <h3>模式识别专家</h3>
              <span class="agent-badge">图案</span>
            </div>
            <p class="agent-detail-description">
              模式讲述故事——工厂、观察者、上帝对象、复制粘贴编程。该代理读取您的代码就像考古学家读取文物一样。它可以发现好的模式（有意的设计）、反模式（累积的技术债务）以及您发誓稍后会重构的重复块。运行像 jscpd 这样的工具，因为人类会错过机器立即捕获的重复。
            </p>
            <h4>检测区域</h4>
            <ul>
              <li>设计模式（工厂、单例、观察者等）</li>
              <li>反模式和代码异味</li>
              <li>TODO/FIXME 评论</li>
              <li>上帝对象和循环依赖</li>
              <li>命名一致性</li>
              <li>代码重复</li>
            </ul>
            <div class="card-code-block">
              <pre><code>claude agent pattern-recognition-specialist</code></pre>
            </div>
          </div>

          <div class="agent-detail" id="code-simplicity-reviewer">
            <div class="agent-detail-header">
              <h3>代码简单性审查者</h3>
              <span class="agent-badge">质量</span>
            </div>
            <p class="agent-detail-description">
              简单就是暴力的纪律。该代理询问“您真的需要这个吗？”关于每一行、每一个抽象、每一个依赖。 YAGNI 不是建议，而是法律。您的 200 行功能具有三层间接层？该代理将向您展示具有相同功能的 50 行版本。复杂性是一种负担；简单的化合物。
            </p>
            <h4>简化检查</h4>
            <ul>
              <li>分析每一行的必要性</li>
              <li>简化复杂逻辑</li>
              <li>消除冗余和重复</li>
              <li>挑战抽象</li>
              <li>优化可读性</li>
              <li>消除过早的概括</li>
            </ul>
            <div class="card-code-block">
              <pre><code>claude agent code-simplicity-reviewer</code></pre>
            </div>
          </div>
        </section>

        <!-- Research Agents -->
        <section id="research-agents">
          <h2><i class="fa-solid fa-microscope"></i> 研究代理人 (4)</h2>
          <p>别再猜测了。这些代理深入研究文档、GitHub 存储库、git 历史记录和真实示例，为您提供有证据支持的答案。他们比你读得快，比你记得更多，并能合成你可能会错过的模式。非常适合“我实际上应该怎么做？”问题。</p>

          <div class="agent-detail" id="framework-docs-researcher">
            <div class="agent-detail-header">
              <h3>框架文档研究员</h3>
              <span class="agent-badge">研究</span>
            </div>
            <p class="agent-detail-description">
              官方文档分散。 GitHub 的示例不一致。弃用隐藏在变更日志中。该代理将所有内容整合在一起——文档、源代码、版本约束、真实示例。问“如何使用 Hotwire Turbo？”并获取在生产中实际有效的模式，而不是玩具教程。
            </p>
            <h4>能力</h4>
            <ul>
              <li>获取官方框架和库文档</li>
              <li>确定特定于版本的限制和弃用</li>
              <li>在 GitHub 上搜索实际使用示例</li>
              <li>使用分析gem/库源代码 <code>bundle show</code></li>
              <li>用实际例子综合研究结果</li>
            </ul>
            <div class="card-code-block">
              <pre><code>claude agent framework-docs-researcher "Research Hotwire Turbo patterns"</code></pre>
            </div>
          </div>

          <div class="agent-detail" id="best-practices-researcher">
            <div class="agent-detail-header">
              <h3>最佳实践研究员</h3>
              <span class="agent-badge">研究</span>
            </div>
            <p class="agent-detail-description">
              “最佳实践”无处不在且相互矛盾。该代理通过评估来源（官方文档、可信博客、真实的 GitHub 存储库）、检查新近度并综合可行的指导来消除噪音。您将获得代码模板、可扩展的模式以及值得信赖的答案，而不是 StackOverflow 复制粘贴轮盘赌。
            </p>
            <h4>能力</h4>
            <ul>
              <li>利用多个来源（Context7 MCP、网络搜索、GitHub）</li>
              <li>评估信息质量和新近度</li>
              <li>综合为可操作的指导</li>
              <li>提供代码示例和模板</li>
              <li>研究问题模板和社区参与</li>
            </ul>
            <div class="card-code-block">
              <pre><code>claude agent best-practices-researcher "Find pagination patterns"</code></pre>
            </div>
          </div>

          <div class="agent-detail" id="git-history-analyzer">
            <div class="agent-detail-header">
              <h3>git 历史分析器</h3>
              <span class="agent-badge">git</span>
            </div>
            <p class="agent-detail-description">
              您的代码库有历史记录——决策、模式、错误。该代理使用 git 工具进行考古学：文件演变、责任分析、贡献者专业知识映射。问“为什么会有这段代码？”并获得解释它的提交。发现错误出现的模式。了解埋藏在历史中的设计决策。
            </p>
            <h4>分析技术</h4>
            <ul>
              <li>使用跟踪文件演变 <code>git log --follow</code></li>
              <li>使用确定代码来源 <code>git blame -w -C -C -C</code></li>
              <li>从提交历史中识别模式</li>
              <li>绘制关键贡献者和专业领域</li>
              <li>提取问题和修复的历史模式</li>
            </ul>
            <div class="card-code-block">
              <pre><code>claude agent git-history-analyzer "Analyze changes to User model"</code></pre>
            </div>
          </div>

          <div class="agent-detail" id="repo-research-analyst">
            <div class="agent-detail-header">
              <h3>回购研究分析师</h3>
              <span class="agent-badge">研究</span>
            </div>
            <p class="agent-detail-description">
              每个存储库都有约定——一些记录在案的、最部落的知识。该代理读取 ARCHITECTURE.md、问题模板、PR 模式和实际代码来对标准进行逆向工程。非常适合加入新项目或确保您的公关符合团队的隐含风格。找到没有人写下的规则。
            </p>
            <h4>分析领域</h4>
            <ul>
              <li>架构和文档文件（ARCHITECTURE.md、README.md、CLAUDE.md）</li>
              <li>有关模式和约定的 GitHub 问题</li>
              <li>问题/公关模板和指南</li>
              <li>使用 ast-grep 或 rg 的实现模式</li>
              <li>项目特定约定</li>
            </ul>
            <div class="card-code-block">
              <pre><code>claude agent repo-research-analyst</code></pre>
            </div>
          </div>
        </section>

        <!-- Workflow Agents -->
        <section id="workflow-agents">
          <h2><i class="fa-solid fa-gears"></i> 工作流程代理 (5)</h2>
          <p>你讨厌做的乏味工作。这些代理负责处理繁琐的工作——重现错误、解决 PR​​ 评论、运行 linter、分析规范。他们速度很快，不会抱怨，而且可以让你有时间去解决有趣的问题，而不是机械问题。</p>

          <div class="agent-detail" id="bug-reproduction-validator">
            <div class="agent-detail-header">
              <h3>错误重现验证器</h3>
              <span class="agent-badge">虫子</span>
            </div>
            <p class="agent-detail-description">
              一半的错误报告不是错误，而是用户错误、环境问题或被误解的功能。该代理系统地重现所报告的行为，对其发现的内容进行分类（已确认、无法重现、不是错误等），并评估严重性。使您免于追逐幽灵或错过真正的问题。
            </p>
            <h4>分类类型</h4>
            <ul>
              <li><strong>确认的</strong> - 错误已成功重现</li>
              <li><strong>无法重现</strong> - 无法重现</li>
              <li><strong>不是错误</strong> - 预期行为</li>
              <li><strong>环境的</strong> - 环境特定问题</li>
              <li><strong>数据</strong> - 数据相关问题</li>
              <li><strong>用户错误</strong> - 用户误解</li>
            </ul>
            <div class="card-code-block">
              <pre><code>claude agent bug-reproduction-validator</code></pre>
            </div>
          </div>

          <div class="agent-detail" id="pr-comment-resolver">
            <div class="agent-detail-header">
              <h3>前评论解析器</h3>
              <span class="agent-badge">PR</span>
            </div>
            <p class="agent-detail-description">
              代码审查评论堆积如山。该代理读取它们，计划修复，实施更改，并报告它所做的事情。它不会与审稿人争论或跳过硬反馈——它只是系统地解决工作。非常适合在几秒钟内烧完十几条“更改此变量名称”评论。
            </p>
            <h4>工作流程</h4>
            <ul>
              <li>分析代码评审意见</li>
              <li>在实施之前计划好决议</li>
              <li>实施请求的修改</li>
              <li>验证分辨率不会破坏功能</li>
              <li>提供清晰的解决方案报告</li>
            </ul>
            <div class="card-code-block">
              <pre><code>claude agent pr-comment-resolver</code></pre>
            </div>
          </div>

          <div class="agent-detail" id="lint">
            <div class="agent-detail-header">
              <h3>皮棉</h3>
              <span class="agent-badge">质量</span>
            </div>
            <p class="agent-detail-description">
              Linters 是强制一致性的迂腐机器人。该代理为您运行 StandardRB、ERBLint 和 Brakeman — 检查 Ruby 样式、ERB 模板和安全问题。它速度很快（使用俳句模型）并且比 CI 更早捕获格式化噪音。
            </p>
            <h4>工具运行</h4>
            <ul>
              <li><code>bundle exec standardrb</code> - Ruby 文件检查/修复</li>
              <li><code>bundle exec erblint --lint-all</code> - ERB 模板</li>
              <li><code>bin/brakeman</code> - 安全扫描</li>
            </ul>
            <div class="card-code-block">
              <pre><code>claude agent lint</code></pre>
            </div>
          </div>

          <div class="agent-detail" id="spec-flow-analyzer">
            <div class="agent-detail-header">
              <h3>规格流分析仪</h3>
              <span class="agent-badge">测试</span>
            </div>
            <p class="agent-detail-description">
              规范总是存在差距——没有人考虑到的边缘情况、模糊的需求、缺失的错误状态。该代理绘制所有可能的用户流程，识别不清楚或缺失的内容，并生成您需要向利益相关者询问的问题。在编码之前运行以避免构建错误的东西。
            </p>
            <h4>分析领域</h4>
            <ul>
              <li>映射所有可能的用户流和排列</li>
              <li>识别差距、歧义和缺失的规范</li>
              <li>考虑不同的用户类型、角色、权限</li>
              <li>分析错误状态和边缘情况</li>
              <li>产生需要澄清的关键问题</li>
            </ul>
            <div class="card-code-block">
              <pre><code>claude agent spec-flow-analyzer</code></pre>
            </div>
          </div>

          <div class="agent-detail" id="every-style-editor">
            <div class="agent-detail-header">
              <h3>每种风格的编辑器</h3>
              <span class="agent-badge">内容</span>
            </div>
            <p class="agent-detail-description">
              风格指南是使写作保持一致的任意规则。该代理强制执行Every的特殊怪癖——标题中的标题大小写，没有过度使用的填充词（“实际上”，“非常”），主动语态，牛津逗号。它是一个逐行语法警察，用于检查需要与品牌相匹配的内容。
            </p>
            <h4>风格格纹</h4>
            <ul>
              <li>标题中的标题大小写，其他地方的句子大小写</li>
              <li>公司单数/复数用法</li>
              <li>删除过度使用的词语（实际上、非常、只是）</li>
              <li>强制使用主动语态</li>
              <li>应用格式规则（牛津逗号、破折号）</li>
            </ul>
            <div class="card-code-block">
              <pre><code>claude agent every-style-editor</code></pre>
            </div>
          </div>
        </section>

        <!-- Design Agents -->
        <section id="design-agents">
          <h2><i class="fa-solid fa-palette"></i> 设计代理 (3)</h2>
          <p>设计就是迭代。这些代理会截取屏幕截图，将其与 Figma 进行比较，进行有针对性的改进，然后重复。他们修复间距、对齐方式、颜色、版式——这些视觉细节最终形成了完美的效果。非常适合缩小“它有效”和“它看起来不错”之间的差距。</p>

          <div class="agent-detail" id="design-iterator">
            <div class="agent-detail-header">
              <h3>设计迭代器</h3>
              <span class="agent-badge">设计</span>
            </div>
            <p class="agent-detail-description">
              设计不会一次性完成。该代理运行一个循环：对 UI 进行屏幕截图，分析问题所在（间距、颜色、对齐方式），实施 3-5 个有针对性的修复，然后重复。运行 10 次迭代，观察粗糙的界面通过系统的细化转变为精美的设计。
            </p>
            <h4>过程</h4>
            <ul>
              <li>对目标元素进行集中截图</li>
              <li>分析当前状态并确定 3-5 项改进</li>
              <li>实施有针对性的 CSS/设计更改</li>
              <li>所做的文档更改</li>
              <li>重复指定的迭代次数（默认 10）</li>
            </ul>
            <div class="card-code-block">
              <pre><code>claude agent design-iterator</code></pre>
            </div>
          </div>

          <div class="agent-detail" id="figma-design-sync">
            <div class="agent-detail-header">
              <h3>Figma 设计同步</h3>
              <span class="agent-badge">菲格玛</span>
            </div>
            <p class="agent-detail-description">
              设计师给你一个 Figma 文件。你建造它。然后：“间距错误，字体不对，颜色不匹配。”该代理会将您的实现与 Figma 规范进行比较，识别每个视觉差异，并自动修复它们。设计师保持快乐。你保持理智。
            </p>
            <h4>工作流程</h4>
            <ul>
              <li>从 Figma 中提取设计规范</li>
              <li>捕获实施屏幕截图</li>
              <li>进行系统的视觉比较</li>
              <li>进行精确的代码更改以修复差异</li>
              <li>验证实施是否符合设计</li>
            </ul>
            <div class="card-code-block">
              <pre><code>claude agent figma-design-sync</code></pre>
            </div>
          </div>

          <div class="agent-detail" id="design-implementation-reviewer">
            <div class="agent-detail-header">
              <h3>设计-实施-评审员</h3>
              <span class="agent-badge">审查</span>
            </div>
            <p class="agent-detail-description">
              在发布 UI 更改之前，请运行此代理。它将您的实现与 Figma 在像素级别（布局、版式、颜色、间距、响应行为）进行比较。使用 Opus 模型进行详细的视觉分析。捕获用户注意到但您没有注意到的“足够接近”的错误。
            </p>
            <h4>比较领域</h4>
            <ul>
              <li>布局和结构</li>
              <li>版式（字体、大小、粗细）</li>
              <li>颜色和主题</li>
              <li>间距和对齐</li>
              <li>不同的视口尺寸</li>
            </ul>
            <div class="card-code-block">
              <pre><code>claude agent design-implementation-reviewer</code></pre>
            </div>
          </div>
        </section>

        <!-- Docs Agents -->
        <section id="docs-agents">
          <h2><i class="fa-solid fa-file-lines"></i> 文件代理 (1)</h2>

          <div class="agent-detail" id="ankane-readme-writer">
            <div class="agent-detail-header">
              <h3>ankane 自述文件编写者</h3>
              <span class="agent-badge">文档</span>
            </div>
            <p class="agent-detail-description">
              安德鲁·凯恩 (Andrew Kane) 编写的自述文件是清晰的典范——简洁、可浏览、零废话。该代理以这种风格生成 gem 文档：每句话最多 15 个单词、命令式语音、单一用途代码示例。如果您的自述文件杂乱无章，此代理将修复它。
            </p>
            <h4>部分顺序</h4>
            <ol>
              <li>标题（标题+描述）</li>
              <li>安装</li>
              <li>快速入门</li>
              <li>用法</li>
              <li>选项</li>
              <li>升级中</li>
              <li>贡献</li>
              <li>执照</li>
            </ol>
            <h4>风格指南</h4>
            <ul>
              <li>贯穿始终的命令语气</li>
              <li>每句话最多 15 个单词</li>
              <li>单一用途代码围栏</li>
              <li>最多 4 个徽章</li>
              <li>没有 HTML 注释</li>
            </ul>
            <div class="card-code-block">
              <pre><code>claude agent ankane-readme-writer</code></pre>
            </div>
          </div>
        </section>

        <!-- Navigation -->
        <nav class="docs-nav-footer">
          <a href="getting-started.html" class="nav-prev">
            <span class="nav-label">以前的</span>
            <span class="nav-title"><i class="fa-solid fa-arrow-left"></i> 入门</span>
          </a>
          <a href="commands.html" class="nav-next">
            <span class="nav-label">下一个</span>
            <span class="nav-title">命令 <i class="fa-solid fa-arrow-right"></i></span>
          </a>
        </nav>
      </article>
    </main>
  </div>

  <script>
    document.querySelector('[data-sidebar-toggle]')?.addEventListener('click', () => {
      document.querySelector('.docs-sidebar').classList.toggle('open');
    });
  </script>
</body>

</html>
