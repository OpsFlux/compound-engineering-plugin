<overview>
代理和用户应该在同一数据空间中工作，而不是单独的沙箱中。当代理写入文件时，用户可以看到它。当用户编辑某些内容时，代理可以读取更改。这创造了透明度，实现了协作，并消除了对同步层的需求。

**核心原则：** 代理与用户在同一文件系统中运行，而不是围墙花园。
</overview>

<why_shared_workspace>
## 为什么要共享工作区？

### 沙箱反模式

许多代理实现隔离代理：

```
┌─────────────────┐     ┌─────────────────┐
│   User Space    │     │   Agent Space   │
├─────────────────┤     ├─────────────────┤
│ Documents/      │     │ agent_output/   │
│ user_files/     │  ←→ │ temp_files/     │
│ settings.json   │sync │ cache/          │
└─────────────────┘     └─────────────────┘
```


问题：
- 需要一个同步层在空间之间移动数据
- 用户无法轻松检查代理工作
- 代理无法建立在用户贡献的基础上
- 状态重复
- 保持空间一致的复杂性

### 共享工作区模式

```
┌─────────────────────────────────────────┐
│           Shared Workspace              │
├─────────────────────────────────────────┤
│ Documents/                              │
│ ├── Research/                           │
│ │   └── {bookId}/        ← Agent writes │
│ │       ├── full_text.txt               │
│ │       ├── introduction.md  ← User can edit │
│ │       └── sources/                    │
│ ├── Chats/               ← Both read/write │
│ └── profile.md           ← Agent generates, user refines │
└─────────────────────────────────────────┘
         ↑                    ↑
       User                 Agent
       (UI)               (Tools)
```


好处：
- 用户可以检查、编辑和扩展代理工作
- 代理可以基于用户的贡献
- 无需同步层
- 完全透明
- 单一事实来源
</why_shared_workspace>

<directory_structure>
## 设计您的共享工作空间

### 按域划分的结构

按数据代表的内容而不是创建者进行组织：

```
Documents/
├── Research/
│   └── {bookId}/
│       ├── full_text.txt        # Agent downloads
│       ├── introduction.md      # Agent generates, user can edit
│       ├── notes.md             # User adds, agent can read
│       └── sources/
│           └── {source}.md      # Agent gathers
├── Chats/
│   └── {conversationId}.json    # Both read/write
├── Exports/
│   └── {date}/                  # Agent generates for user
└── profile.md                   # Agent generates from photos
```


### 不要按演员构建

```
# BAD - Separates by who created it
Documents/
├── user_created/
│   └── notes.md
├── agent_created/
│   └── research.md
└── system/
    └── config.json
```


这会造成人为的界限，并使协作变得更加困难。

### 使用元数据约定

如果您需要跟踪谁创建/修改了某些内容：

```markdown
<!-- introduction.md -->
---
created_by: agent
created_at: 2024-01-15
last_modified_by: user
last_modified_at: 2024-01-16
---

# Introduction to Moby Dick

This personalized introduction was generated by your reading assistant
and refined by you on January 16th.
```

</directory_structure>

<file_tools>
## 共享工作区的文件工具

为代理提供应用程序使用的相同文件原语：

```swift
// iOS/Swift implementation
struct FileTools {
    static func readFile() -> AgentTool {
        tool(
            name: "read_file",
            description: "Read a file from the user's documents",
            parameters: ["path": .string("File path relative to Documents/")],
            execute: { params in
                let path = params["path"] as! String
                let documentsURL = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)[0]
                let fileURL = documentsURL.appendingPathComponent(path)
                let content = try String(contentsOf: fileURL)
                return ToolResult(text: content)
            }
        )
    }

    static func writeFile() -> AgentTool {
        tool(
            name: "write_file",
            description: "Write a file to the user's documents",
            parameters: [
                "path": .string("File path relative to Documents/"),
                "content": .string("File content")
            ],
            execute: { params in
                let path = params["path"] as! String
                let content = params["content"] as! String
                let documentsURL = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)[0]
                let fileURL = documentsURL.appendingPathComponent(path)

                // Create parent directories if needed
                try FileManager.default.createDirectory(
                    at: fileURL.deletingLastPathComponent(),
                    withIntermediateDirectories: true
                )

                try content.write(to: fileURL, atomically: true, encoding: .utf8)
                return ToolResult(text: "Wrote \(path)")
            }
        )
    }

    static func listFiles() -> AgentTool {
        tool(
            name: "list_files",
            description: "List files in a directory",
            parameters: ["path": .string("Directory path relative to Documents/")],
            execute: { params in
                let path = params["path"] as! String
                let documentsURL = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)[0]
                let dirURL = documentsURL.appendingPathComponent(path)
                let contents = try FileManager.default.contentsOfDirectory(atPath: dirURL.path)
                return ToolResult(text: contents.joined(separator: "\n"))
            }
        )
    }

    static func searchText() -> AgentTool {
        tool(
            name: "search_text",
            description: "Search for text across files",
            parameters: [
                "query": .string("Text to search for"),
                "path": .string("Directory to search in").optional()
            ],
            execute: { params in
                // Implement text search across documents
                // Return matching files and snippets
            }
        )
    }
}
```


### TypeScript/Node.js 实施

```typescript
const fileTools = [
  tool(
    "read_file",
    "Read a file from the workspace",
    { path: z.string().describe("File path") },
    async ({ path }) => {
      const content = await fs.readFile(path, 'utf-8');
      return { text: content };
    }
  ),

  tool(
    "write_file",
    "Write a file to the workspace",
    {
      path: z.string().describe("File path"),
      content: z.string().describe("File content")
    },
    async ({ path, content }) => {
      await fs.mkdir(dirname(path), { recursive: true });
      await fs.writeFile(path, content, 'utf-8');
      return { text: `Wrote ${path}` };
    }
  ),

  tool(
    "list_files",
    "List files in a directory",
    { path: z.string().describe("Directory path") },
    async ({ path }) => {
      const files = await fs.readdir(path);
      return { text: files.join('\n') };
    }
  ),

  tool(
    "append_file",
    "Append content to a file",
    {
      path: z.string().describe("File path"),
      content: z.string().describe("Content to append")
    },
    async ({ path, content }) => {
      await fs.appendFile(path, content, 'utf-8');
      return { text: `Appended to ${path}` };
    }
  ),
];
```

</file_tools>

<ui_integration>
## UI 与共享工作区集成

UI 应观察代理写入的相同文件：

### 模式 1：基于文件的反应性 (iOS)

```swift
class ResearchViewModel: ObservableObject {
    @Published var researchFiles: [ResearchFile] = []

    private var watcher: DirectoryWatcher?

    func startWatching(bookId: String) {
        let researchPath = documentsURL
            .appendingPathComponent("Research")
            .appendingPathComponent(bookId)

        watcher = DirectoryWatcher(url: researchPath) { [weak self] in
            // Reload when agent writes new files
            self?.loadResearchFiles(from: researchPath)
        }

        loadResearchFiles(from: researchPath)
    }
}

// SwiftUI automatically updates when files change
struct ResearchView: View {
    @StateObject var viewModel = ResearchViewModel()

    var body: some View {
        List(viewModel.researchFiles) { file in
            ResearchFileRow(file: file)
        }
    }
}
```


### 模式 2：共享数据存储

当文件监视不可行时，请使用共享数据存储：

```swift
// Shared service that both UI and agent tools use
class BookLibraryService: ObservableObject {
    static let shared = BookLibraryService()

    @Published var books: [Book] = []
    @Published var analysisRecords: [AnalysisRecord] = []

    func addAnalysisRecord(_ record: AnalysisRecord) {
        analysisRecords.append(record)
        // Persists to shared storage
        saveToStorage()
    }
}

// Agent tool writes through the same service
tool("publish_to_feed", async ({ bookId, content, headline }) => {
    let record = AnalysisRecord(bookId: bookId, content: content, headline: headline)
    BookLibraryService.shared.addAnalysisRecord(record)
    return { text: "Published to feed" }
})

// UI observes the same service
struct FeedView: View {
    @StateObject var library = BookLibraryService.shared

    var body: some View {
        List(library.analysisRecords) { record in
            FeedItemRow(record: record)
        }
    }
}
```


### 模式 3：混合（文件 + 索引）

使用文件作为内容，使用数据库作为索引：

```
Documents/
├── Research/
│   └── book_123/
│       └── introduction.md   # Actual content (file)

Database:
├── research_index
│   └── { bookId: "book_123", path: "Research/book_123/introduction.md", ... }
```


```swift
// Agent writes file
await writeFile("Research/\(bookId)/introduction.md", content)

// And updates index
await database.insert("research_index", {
    bookId: bookId,
    path: "Research/\(bookId)/introduction.md",
    title: extractTitle(content),
    createdAt: Date()
})

// UI queries index, then reads files
let items = database.query("research_index", where: bookId == "book_123")
for item in items {
    let content = readFile(item.path)
    // Display...
}
```

</ui_integration>

<collaboration_patterns>
## 代理-用户协作模式

### 模式：代理草稿，用户细化

```
1. Agent generates introduction.md
2. User opens in Files app or in-app editor
3. User makes refinements
4. Agent can see changes via read_file
5. Future agent work builds on user refinements
```


代理的系统提示应确认这一点：

```markdown
## Working with User Content

When you create content (introductions, research notes, etc.), the user may
edit it afterward. Always read existing files before modifying them—the user
may have made improvements you should preserve.

If a file exists and has been modified by the user (check the metadata or
compare to your last known version), ask before overwriting.
```


### 模式：用户种子，代理扩展

```
1. User creates notes.md with initial thoughts
2. User asks: "Research more about this"
3. Agent reads notes.md to understand context
4. Agent adds to notes.md or creates related files
5. User continues building on agent additions
```


### 模式：仅追加协作

对于聊天日志或活动流：

```markdown
<!-- activity.md - Both append, neither overwrites -->

## 2024-01-15

**User:** Started reading "Moby Dick"

**Agent:** Downloaded full text and created research folder

**User:** Added highlight about whale symbolism

**Agent:** Found 3 academic sources on whale symbolism in Melville's work
```

</collaboration_patterns>

<security_considerations>
## 共享工作区的安全性

### 确定工作空间范围

不要让代理访问整个文件系统：

```swift
// GOOD: Scoped to app's documents
let documentsURL = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)[0]

tool("read_file", { path }) {
    // Path is relative to documents, can't escape
    let fileURL = documentsURL.appendingPathComponent(path)
    guard fileURL.path.hasPrefix(documentsURL.path) else {
        throw ToolError("Invalid path")
    }
    return try String(contentsOf: fileURL)
}

// BAD: Absolute paths allow escape
tool("read_file", { path }) {
    return try String(contentsOf: URL(fileURLWithPath: path))  // Can read /etc/passwd!
}
```


### 保护敏感文件

```swift
let protectedPaths = [".env", "credentials.json", "secrets/"]

tool("read_file", { path }) {
    if protectedPaths.any({ path.contains($0) }) {
        throw ToolError("Cannot access protected file")
    }
    // ...
}
```


### 审核代理操作

记录代理读/写的内容：

```swift
func logFileAccess(action: String, path: String, agentId: String) {
    logger.info("[\(agentId)] \(action): \(path)")
}

tool("write_file", { path, content }) {
    logFileAccess(action: "WRITE", path: path, agentId: context.agentId)
    // ...
}
```

</security_considerations>

<examples>
## 现实世界的例子：每个读者

Every Reader 应用程序使用共享工作区进行研究：

```
Documents/
├── Research/
│   └── book_moby_dick/
│       ├── full_text.txt           # Agent downloads from Gutenberg
│       ├── introduction.md         # Agent generates, personalized
│       ├── sources/
│       │   ├── whale_symbolism.md  # Agent researches
│       │   └── melville_bio.md     # Agent researches
│       └── user_notes.md           # User can add their own notes
├── Chats/
│   └── 2024-01-15.json             # Chat history
└── profile.md                       # Agent generated from photos
```


**它是如何工作的：**

1. 用户将“Moby Dick”添加到库中
2. 用户启动研究代理
3. 代理将全文下载至`Research/book_moby_dick/full_text.txt`
4. 代理人研究并写信给`sources/`
5. 代理根据用户的阅读资料生成`introduction.md`
6. 用户可以查看应用程序或Files.app中的所有文件
7. 用户可以编辑`introduction.md`来完善它
8. 聊天代理在回答问题时可以读取所有这些上下文
</examples>

<icloud_sync>
## 用于多设备同步的 iCloud 文件存储 (iOS)

对于代理本机 iOS 应用程序，请使用 iCloud Drive 的文档文件夹作为共享工作区。这为您提供**免费、自动的多设备同步**，无需构建同步层或运行服务器。

### 为什么选择 iCloud 文档？

|方法|成本|复杂性 |离线 |多设备|
|----------|------|------------|---------|----------------|
|自定义后端+同步| $$$ |高|手册|是的 |
| CloudKit数据库|免费套餐限制 |中等|手册|是的 |
| **iCloud 文档** |免费（用户的存储空间）|低|自动|自动|

iCloud 文档：
- 使用用户现有的 iCloud 存储空间（免费 5GB，大多数用户有更多）
- 在所有用户设备之间自动同步
- 离线工作，在线同步
- 文件在 Files.app 中可见以实现透明度
- 无服务器成本，无需维护同步代码

### 实现模式

```swift
// Get the iCloud Documents container
func iCloudDocumentsURL() -> URL? {
    FileManager.default.url(forUbiquityContainerIdentifier: nil)?
        .appendingPathComponent("Documents")
}

// Your shared workspace lives in iCloud
class SharedWorkspace {
    let rootURL: URL

    init() {
        // Use iCloud if available, fall back to local
        if let iCloudURL = iCloudDocumentsURL() {
            self.rootURL = iCloudURL
        } else {
            // Fallback to local Documents (user not signed into iCloud)
            self.rootURL = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask).first!
        }
    }

    // All file operations go through this root
    func researchPath(for bookId: String) -> URL {
        rootURL.appendingPathComponent("Research/\(bookId)")
    }

    func journalPath() -> URL {
        rootURL.appendingPathComponent("Journal")
    }
}
```


### iCloud 中的目录结构

```
iCloud Drive/
└── YourApp/                          # Your app's container
    └── Documents/                    # Visible in Files.app
        ├── Journal/
        │   ├── user/
        │   │   └── 2025-01-15.md     # Syncs across devices
        │   └── agent/
        │       └── 2025-01-15.md     # Agent observations sync too
        ├── Experiments/
        │   └── magnesium-sleep/
        │       ├── config.json
        │       └── log.json
        └── Research/
            └── {topic}/
                └── sources.md
```


### 处理同步冲突

iCloud 会自动处理冲突，但您应该为此进行设计：

```swift
// Check for conflicts when reading
func readJournalEntry(at url: URL) throws -> JournalEntry {
    // iCloud may create .icloud placeholder files for not-yet-downloaded content
    if url.pathExtension == "icloud" {
        // Trigger download
        try FileManager.default.startDownloadingUbiquitousItem(at: url)
        throw FileNotYetAvailableError()
    }

    let data = try Data(contentsOf: url)
    return try JSONDecoder().decode(JournalEntry.self, from: data)
}

// For writes, use coordinated file access
func writeJournalEntry(_ entry: JournalEntry, to url: URL) throws {
    let coordinator = NSFileCoordinator()
    var error: NSError?

    coordinator.coordinate(writingItemAt: url, options: .forReplacing, error: &error) { newURL in
        let data = try? JSONEncoder().encode(entry)
        try? data?.write(to: newURL)
    }

    if let error = error {
        throw error
    }
}
```


### 这可以实现什么

1. **用户在 iPhone 上开始实验** → 代理创建 `Experiments/sleep-tracking/config.json`
2. **用户在 iPad 上打开应用程序** → 相同的实验可见，无需同步代码
3. **代理在 iPhone 上记录观察结果** → 自动同步到 iPad
4. **用户在 iPad 上编辑日记** → iPhone 会看到编辑内容

### 所需权利

添加到您的应用程序的权利：

```xml
<key>com.apple.developer.icloud-container-identifiers</key>
<array>
    <string>iCloud.com.yourcompany.yourapp</string>
</array>
<key>com.apple.developer.icloud-services</key>
<array>
    <string>CloudDocuments</string>
</array>
<key>com.apple.developer.ubiquity-container-identifiers</key>
<array>
    <string>iCloud.com.yourcompany.yourapp</string>
</array>
```


### 何时不使用 iCloud 文档

- **敏感数据** - 使用钥匙串或加密的本地存储代替
- **高频写入** - iCloud 同步有延迟；使用本地+定期同步
- **大型媒体文件** - 考虑 CloudKit 资产或点播资源
- **在用户之间共享** - iCloud 文档是单用户的；使用CloudKit进行分享
</icloud_sync>

<checklist>
## 共享工作空间清单

架构：
- [ ] 代理和用户数据的单个共享目录
- [ ] 按领域组织，而不是按参与者组织
- [ ] 文件工具范围仅限于工作区（无法转义）
- [ ] 敏感文件的受保护路径

工具：
- [ ] `read_file` - 读取工作区中的任何文件
- [ ] `write_file` - 在工作区中写入任何文件
- [ ] `list_files` - 浏览目录结构
- [ ] `search_text` - 跨文件查找内容（可选）

用户界面集成：
- [ ] UI 观察代理写入的相同文件
- [ ] 更改立即反映（文件查看或共享存储）
- [ ] 用户可以编辑代理创建的文件
- [ ] 代理在覆盖之前读取用户修改

合作：
- [ ] 系统提示确认用户可以编辑文件
- [ ] 代理在覆盖之前检查用户修改
- [ ] 元数据跟踪创建/修改者（可选）

多设备（iOS）：
- [ ] 使用 iCloud 文档共享工作区（免费同步）
- [ ] 如果 iCloud 不可用，则回退到本地文档
- [ ] 处理`.icloud`占位符文件（触发下载）
- [ ] 使用 NSFileCoordinator 进行冲突安全写入
</checklist>